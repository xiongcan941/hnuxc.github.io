---
layout:     post
title:      知识点总结
subtitle:   知识点总结
date:       2023-05-19
author:     xc
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - linux
    - c++
---

# 知识点总结

## 指针 
指针存储的是内存的地址

指针是一个**变量**，他的值是可以变得，他里面存的是一个**地址**
假设我们定义一个指针 int *p; int a;
如果p = &a;
这个时候我们知道，a是一个变量，那么内存必定要给他分配一个地址来存储他，p指向a的意思就是p里面存的就是a的地址。所以p就是一个存着地址的变量。
既然我们知道p里面存着a的地址，那么我们要找a就非常方便了，*p就表示p存的地址里面的值，也就是a的值。
这句话怎么理解呢？
1.p存的是地址，比作你住的地方，那么*p就表示你了，因为*p就表示这个地址里面的数据。
这个时候*p和a是完全一样的了，假如你要改变a的值。a = a+1和*p =*p+1是完全一样的，都能达到对a进行操作的目的。但是*p =*p+1和*p = *(p+1)是不一样的，这个用的时候要特别注意，因为p里面是地址,那么*（p+1）就表示这个地址加1后，地址加1那不就是换了一个地址吗？换了一个地址后里面存的就肯定不是a了，就像可能是你的邻居了。因为地址变了，所以就是p变了，因此*也变了，这个地方有点难理解，楼主多琢磨琢磨。
 总结一句话：指针是一个万能钥匙，可以指向任何一个地址，可以改变任何一个地址里面的数据（只读的除外），因此使用指针要注意安全，以免发生异常。

## .与->的区别
你的c++结构体是对象时使用 “.” ,是指针时用 "->"

## C++虚函数表

每个包含了虚函数的类都包含一个虚表

当一个类A继承另一个类B时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表

对于一个类来说，如果类中存在虚函数，那么该类的大小就会多4个字节，然而这4个字节就是一个指针的大小，这个指针指向虚函数表。所以，如果对象存在虚函数，那么编译器就会生成一个指向虚函数表的指针，所有的虚函数都存在于这个表中，虚函数表可以理解为一个指针数组，每个单元用来存放虚函数的地址

 虚函数（Virtual Function）是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

编译器把生成的虚函数表放在了最前面

## c++中char数组比较方式
利用:
```
int strcmp(const char* s1,const char* s2);
```
(1) 当s1 < s2时，返回负数；

(2) 当s1 == s2时，返回值 = 0；

(3) 当s1 > s2时，返回正数。

如果使用==，比较的是两个数组的地址是否相等，但是string可以使用==

## 正则表达式小括号，中括号，大括号以及+ ? *
()是为了提取匹配的字符串，表达式中有几个()就有几个相应的匹配字符串
(.*?)表示不贪婪的非换行符字符串
(\d\d)表示两个数字

[]是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\s*]表示空格或者*号。

{}一般用来表示匹配的长度，比如 \s{3} 表示匹配三个空格，\s{1,3}表示匹配一到三个空格。

(0-9) 匹配 '0-9′ 本身。 [0-9]* 匹配数字（注意后面有 *，可以为空）[0-9]+ 匹配数字（注意后面有 +，不可以为空）{1-9} 写法错误。

[0-9]{0,9} 表示长度为 0 到 9 的数字字符串。

runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。

runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。

colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次或1次）。

## setuid权限
原本表示文件所有者权限中的 x 权限位，却出现了 s 权限，此种权限通常称为 SetUID，简称 SUID 特殊权限。

SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。

举一个例子，我们都知道，Linux 系统中所有用户的密码数据都记录在 /etc/shadow 这个文件中，通过 ll /etc/shadow 命令可以看到，此文件的权限是 0（---------），也就是说，普通用户对此文件没有任何操作权限。

这就会产生一个问题，为什么普通用户可以使用 passwd 命令修改自己的密码呢？

本节开头已经显示了 passwd 命令的权限配置，可以看到，此命令拥有 SUID 特殊权限，而且其他人对此文件也有执行权限，这就意味着，任何一个用户都可以用文件所有者，也就是 root 的身份去执行 passwd 命令。
Linux 系统中，绝对多数命令的文件所有者默认都是 root。

换句话说，当普通用户使用 passwd 命令尝试更改自己的密码时，实际上是在以 root 的身份执行passwd命令，正因为 root 可以将密码写入 /etc/shadow 文件，所以普通用户也能做到。只不过，一旦命令执行完成，普通用户所具有的 root身份也随之消失。

# c++函数后加冒号
冒号后面跟的是赋值，这种写法是C++的特性。
A(int aa,int bb):a(aa),b(bb){}

# struct初始化
```
struct A{
	int b;
	int c;
};
```

- **顺序初始化**

A a={1,2}

- **指定初始化**

A a={.b=1,.c=2}

A a={b:1,c:2}

- **构造函数初始化**

```
struct A{
	A(int b,int c){
		this->b=b;
		this->c=c;
	}
	int b;
	int c;
	/*
	A(int b,int c):b(b),c(c){}
	*/
}
```

# kmem_cache_alloc代码流程
![](https://img2022.cnblogs.com/blog/2355803/202203/2355803-20220322220219717-633843017.png)

# 静态数据的存储
全局（静态）存储区：分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BSS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0.存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
C++中static的内部实现机制：静态数据成员要在程序一开始运行时就必须存在，因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
这样，它的空间分配有三个可能的地方，一是作为类的外部接口的头文件，那里有类声明；二是类定义的内部实现，那里有类的成员函数定义；三是应用程序的 main() 函数前的全局数据声明和定义处。

静态数据成员要实际地分配空间，故不能在类的声明中定义（只能声明数据成员）。类声明只声明一个类的"尺寸和规格"，并不进行实际的内存分配，所以在类声明中写成定义是错误的。它也不能在头文件中类声明的外部定义，因为那会造成在多个使用该类的源文件中，对其重复定义。

static 被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

优势：可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。


在 C/C++ 中static的作用
 总的来说
（1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。

（2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。

（3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。

（4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。

（5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。

静态变量与普通变量

静态全局变量有以下特点：

（1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;

（2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；

（3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

（1）全局变量和全局静态变量的区别

1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。

2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。

静态局部变量有以下特点：

（1）该变量在全局数据区分配内存；

（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；

（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；

（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。

# db dw dd 与equ差别
db dw dd 定义的变量是作为数据存在的，执行传送指令时cpu通过读内存得到操作数 address1 

equ 定义的变量是作为立即数存在，相当于mov bx,2000h，不占用存储空间

如果是需要反复修改的，或者在程序执行中根据环境等修改的数据用前者比较合适；如果是固定的数值equ效率更高。

# 控制寄存器
CR0：位0用PE标记，位31用PG标记，这两个位控制分段和分页管理机制的操作。

PE控制分段管理机制：PE=0，处理器运行于实模式;PE=1，处理器运行于保护模式。

PG控制分页管理机制：PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用；PG=1，启用分页管理机制，此时线性地址经分页管理机制转换为物理地址。由此可知，如果要启用分页机制，那么PE和PG标志都要置位。

CR3用于保存页目录表页面的物理地址，因此被称为PDBR。由于页目录是页对齐的，所以CR3中低12位必须为0，从CR3中取值时，低12位被忽略。

# PG_开头的宏，这是页表项或页目录项的属性.

PG 前缀表示页表项或页目录项，US表示第2 位的US位，RW 表示第1 位的RW位，P表示第0 位的P位。 PG_P_1 表示 P 位的值为 1，表示此页内存已存在。 PG_P_0 表示 P 位的值为 0，表示此页内存不存在。 PG_RW_W 表示 RW 位的值为 W，即 RW=1，表示此页内存允许读、写、执行。 PG_RW_R 表示 RW 位的值为 R，即 RW=0，表示此页内存允许读、执行。 PG_US_S 表示 US 位的值为 S，即 US=0，表示只允许特权级别为 0、1、2 的程序访问此页内存， 3 特权级程序不被允许。 PG_US_U 表示 US 位的值为 U，即 US=1，表示允许所有特权级别程序访问此页内存。

# fork后的写时复制策略
fork系统调用不同于vfork，它会为子进程创建一个虚拟内存空间，并且父子进程的虚拟内存空间都指向同一个物理内存，为什么呢？这是因为子进程也复制了父进程的页表，并且将父进程的页表设置为写保护，当子进程读的时候，就共享父进程的页表去获取物理内存中的值；当子进程写的时候，则会触发写保护的缺页中断，操作系统将为写的那一页分配物理内存空间，并修改子进程页表.操作系统会更新子进程的页表，将虚拟地址映射到新的物理页面上，使子进程拥有自己的独立页面。并且此时由于页表也是写保护，所以也需要为页表页目录分配物理内存空间。

页表是一种数据结构，用于将虚拟地址映射到物理地址。它的主要作用是实现虚拟内存管理，将进程的虚拟地址空间映射到物理内存中的实际存储位置。

通过页表，操作系统可以将磁盘上的数据映射到内存中，以实现虚拟内存的概念。当进程访问虚拟地址时，操作系统会根据页表的映射关系将虚拟地址转换为物理地址，从而确定实际存储位置。如果所需的数据尚未加载到内存中，操作系统会触发页面置换算法将数据从磁盘加载到内存中，并更新页表的映射关系。

除了磁盘映射，页表还可以用于其他映射，例如将共享库映射到进程的地址空间，将内存映射文件映射到内存中等。页表的目的是建立虚拟地址和物理地址之间的映射关系，以提供灵活的内存管理机制，并支持虚拟内存的各种特性，如内存保护、共享和页面置换等。

总结起来，页表是将对磁盘的映射和对内存的映射连接起来的数据结构，它实现了虚拟内存管理，使得操作系统可以将虚拟地址转换为物理地址，并将磁盘上的数据映射到内存中。

在x86架构的操作系统中，CR3寄存器是页表基址寄存器（Page Table Base Register），用于存储当前进程的页表的物理地址。当进程进行上下文切换或地址空间切换时，操作系统会修改CR3寄存器的值以切换到新的页表。

在fork系统调用中，子进程会复制父进程的地址空间，包括页表，此时就是定义一个虚拟内存，保存与父进程一样的对磁盘空间的映射，页表其实也就是连接对磁盘的映射与对内存的映射。在创建子进程时，操作系统会为子进程创建一个新的页表，并将父进程的页表内容复制到子进程的页表中。在这个过程中，CR3寄存器的值不会改变，因为父进程和子进程共享同一个页表基址。

只有在子进程进行写操作时，才会触发写时复制机制，操作系统会为子进程分配新的物理页面，并更新子进程的页表。在这种情况下，操作系统会修改CR3寄存器的值，以切换到新的页表。

因此，fork系统调用不会直接改变CR3寄存器的值，而是在需要修改页表时才会进行相应的切换。

# 页表
每个进程具有不同的页表，而不是程序，页表是将程序所在虚拟地址与物理地址进行相应的映射，所有操作都是在物理内存中进行，如若不是对程序文件的写操作，则不会对磁盘中的文件产生影响，如果对页表所在的虚拟地址进行操作，则会对每个进程相应的物理地址所保存的页表进行操作。

# fork与vfork
1.vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。

2.fork要拷贝父进程的进程环境；而vfork则不需要完全拷贝父进程的进程环境，在子进程没有调用exec和exit之前，子进程与父进程共享进程环境，相当于线程的概念，此时父进程阻塞等待。

为什么会有vfork呢?

因为以前的fork当它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，然后将会有两种行为：

1.执行从父进程那里拷贝过来的代码段

2.调用一个exec执行一个新的代码段

当进程调用exec函数时，一个新程序替换了当前进程的正文，数据，堆和栈段。这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork。vfork并不复制父进程的进程环境，子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子“霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了。
因此，如果创建子进程是为了调用exec执行一个新的程序的时候，就应该使用vfork

# strtok函数
（1）原型

char* strtok(char s[],const char* delim)

当strtok在s字符串中发现参数delim中的分割字符时，则会将该字符改为\0字符。在第一次调用时，strtok()必须给予参数s字符串，往后的调用则将参数s设置为NULL。每次调用成功则返回被分割成片段的指针。

`说明`：strtok只能接收C风格的字符串，如果是string类型，可以使用c_str函数进行转换。

```
vector<string> split2(const string &str, const string &pattern)
{
    char * strc = new char[strlen(str.c_str())+1];
    strcpy(strc, str.c_str());   //string转换成C-string
    vector<string> res;
    char* temp = strtok(strc, pattern.c_str());
    while(temp != NULL)
    {
        res.push_back(string(temp));
        temp = strtok(NULL, pattern.c_str());
		if(temp == NULL)//为什么要这样？
			break;
    }
    delete[] strc;
    return res;
}
```

(2)返回值

当s中的字符查找到末尾时，返回NULL，所以我们要定义while(temp!=NULL)。如果查找不到delim中的字符时，返回当前strtok的字符串的指针。所有delim中包含的字符都会被过滤掉，并将被过滤掉的地方设为一处分割的节点。

（3）注意事项

使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样。第一次分割之后，原字符串s时分割完成之后的第一个字符串，很明显，因为它最后变成了\0，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误，所以可以使用strtok_r函数，char* strtok_r(char *str,const char* delim,char **saveptr);该函数将剩余的字符串保存在saveptr变量中，保证了安全性。

while循环里有一个判断temp是否等于NULL的语句是因为strtok函数分割到最后没东西分的时候会返回一个空指针，所以需要加个判断跳出循环，否则就会出现段错误。

