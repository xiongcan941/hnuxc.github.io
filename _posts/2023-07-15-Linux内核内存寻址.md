# Linux内核内存寻址
## 内存地址
我们应用内存地址作为访问内存单元内容的一种方式，但是，我们必须区分以下三种不同的地址：

 - 逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的方式。每一个逻辑地址都由一个段选择子（16位）和偏移量（32位）组成，其中段选择子用于从GDT中找到对应的`段描述符`，据此找到段基址，由段基址加上偏移量得到对应的线性地址；
 - 线性地址：线性地址是一个32位无符号整数，可以用来表示高达4GB,范围从0x00000000到0xffffffff
 - 物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位无符号整数表示。
 
内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址；接着，第二个称为分页单元的硬件电路把线性地址转换成一个物理地址。

在多处理器系统中，所有CPU都共享同一内存，这意味着RAM芯片可以由独立的CPU并发地访问。因为在RAM芯片上的读或写操作必须串行地执行，因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间。其作用是如果某个RAM芯片空闲，就准许一个CPU访问，如果该芯片忙于另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为但处理器系统中包含一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。

## 硬件中的分段
从80286模型开始，Intel微处理器以两种不同的方式执行地址转换，这两种方式分别称为实模式和保护模式。

### 段选择符和段寄存器
一个逻辑地址由两部分组成，一个段标识符和一个指定段内相对地址的偏移量。段标识符是一个16位长的字段，称为段选择符，而偏移量是一个32位长的字段。

为了快速方便地找到段选择符，处理器提供段寄存器，段寄存器的唯一目的是存放端选择符。这些段寄存器称为cs(代码段寄存器，指向包含程序指令的段）、ds(数据段寄存器）、ss（栈段寄存器、指向包含当前程序栈的段）、fs（堆段寄存器）、es（额外段）。

**段选择符**：16位，`0-1`位为RPL，表示请求特权级，linux中只有00（内核态）和11（用户态）；

`2`位为TI，即表指示器，为0则代表GDT,为1代表LDT

`3-15`位为索引号，根据该索引号到GDT或LDT中找到对应段描述符

cs寄存器还有一个很重要的功能：它含有一个两位的字段，用以指明CPU的当前特权级（CPL)。值0代表最高优先级，值3代表最低优先级。Linux只用0级和3级，分别称之为内核态和用户态。

### 段描述符
每个段描述符由8个字节组成，它放在全局描述符表GDT或者局部描述符表LDT中。

通常只定义一个GDT，而每个进程除了存放在GDT中的段之外如果还需要创建附加的段，就可以有自己的LDT。GDT在主存中的地址和大小存放在dgtr寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。

| 字段名 | 描述|
| ----  | ----|
| Base  | 段基地址(线性地址）|
| G     | 粒度标志，如果该位清0，则段大小以字节为单位，该位为1，则以4KB为单位|
| Limit | 段限长，存放段中最后一个内存单元的偏移量，从而决定段的长度|
| S     | 系统标志，如果它被清0，则这是一个系统段，存储LDT这种关键的数据结构，否则它是一个普通的代码段或数据段|
|Type   | 描述段的类型特征和它的存取权限|
| DPL   | 描述符特权级，用于限制对这个段的存取，他表示为访问这个段要求的CPU最小优先级。因此，DPL设为0的段只能当CPL为0时可访问，DPL设为3的段对任何CPL值都是可访问的|
| p     | 段存在标志，为0表示段当前不在主存中，linux总是把这个表示（第47位）设为1，因为它从来不把整个段交换到磁盘上|
| D或B  | 称为D或B的标志，取决于是代码段还是数据段，如果段偏移量地址是32位长，就基本上把它置为1，如果这个偏移量是16位长，它被清0|
| AVL   | 可以被操作系统使用   |

### 快速访问段描述符
我们回忆一下，逻辑地址由16位段选择符和32位偏移量组成，`段寄存器仅仅存放端选择符`。

为了加速逻辑地址到线性地址的转换，处理器提供一种附加的非变成的寄存器（作用类似于虚拟地址到物理地址的TLB高速缓存），供6个段寄存器使用。每一个非编程段寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。从那时起，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接饮用存放段描述符的CPU寄存器即可。仅当段寄存器的内容发生改变时，才有必要访问GDT或LDT。

`段选择符字段`

 - index:指定了放在GDT或LDT中的相应段描述符的入口
 - TI：指明段描述符是在GDT中（TI=0）或在LDT中（TI=1)
 - RPL:请求者特权级：当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级

由于一个段描述符是8字节长，因此它在GDT或LDT内的相对地址是由段选择符的最高13位的值乘以8得到的。例如：如果GDT在0x0020000(这个值保存在gdtr寄存器中）。且由段选择符所指定的索引号为2，那么相应的段描述符地址是0x00020000+2x8或0x00020010。

GDT的第一项总是设为0，这就确保空段选择符的逻辑地址会被认为是无效的，因此引起一个处理器异常。能够保存在GDT中的段描述符的最大数目就是2的13次方减去1

### 分段单元
分段单元执行以下操作：

- 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址）
- 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。
- 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。

### Linux中的分段
Linux以非常有限的方式使用分段。实际上，分段和分页在某种程度上有点多余。与分段相比，Linux更喜欢使用分页方式。

四个Linux的段描述符字段的值

|段|Base|G|Limit|S|Type|DPL|D/B|P|
|----|----|----|----|----|----|----|----|----|
|用户代码段|0x00000000|1|0xfffff|1|10|3|1|1|
|用户数据段|0x00000000|1|0xfffff|1|2|3|1|1|
|内核代码段|0x00000000|1|0xfffff|1|10|0|1|1|
|内核数据段|0x00000000|1|0xfffff|1|2|0|1|1|

![](https://img2018.cnblogs.com/i-beta/1827556/202001/1827556-20200108095144191-993268543.png)

相应的段选择符由宏__USER_CS,__USER_DS,__KERNEL_CS,__KERNEL_DS分别定义。例如，为了对内核代码段寻址，内核只需要把__KERNEL_CS宏产生的值装进cs段寄存器即可。

由于所有段基地址都为0，所以linux中逻辑地址偏移量字段的值与相应的线性地址的值总是一致的。

### Linux GDT
每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。

每一个GDT中包含的18个段描述符指向下列的段：

- 用户态和内核态下的代码段和数据段共4个
- 任务状态段（TSS)，每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，指的说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G标志被清0，而Limit字段置为0xeb,因为TSS段是236字节长。Type字段置为9或11（可用的32位TSS），且DPL置为0，因为不允许用户态下的进程访问TSS段。
- 1个包含缺省局部描述符表的段，这个段通常是被所有进程共享的段
- 3个局部线程存储段TLS：这种机制运行需多线程应用程序使用最多3个局部于线程的数据段。系统调用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段
- 与高级电源(AMP)相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和shujuduan
- 与支持即插即用（pnp)功能的BIOS服务程序相关的5个段：与前一种一样，当Linux的pnp设备驱动程序调用BIOS函数来检测pnp设备使用的资源时，使用自定义的代码段和数据段
- 被内核用来处理“双重错误”（处理一个异常时可能会引发另一个异常）的特殊TSS段

每个处理器都有它自己的TSS段，因此其对应的GDT项不同。其次，GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）

## 硬件中的分页
分页单元把线性地址转换成物理地址。其中一个关键任务是吧所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。

为了效率起见，线性地址被分成以固定长度为单位的组，称为页。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。

分页单元把所有的RAM分成固定长度的页框（page frame)(有时叫做物理页）。每一个页框包含一个页，也就是说一个页框的长度和一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。

把线性地址映射到物理地址的数据结构称为页表。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。

我们通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。

## 常规分页
页目录：高19位

页表：中间10位

偏移量：低12位

线性地址的转换分两步未完成，每一步都基于一种转换表，第一种转换表称为页目录表，第二种转换表称为页表。

使用这种二级模式的**目的**在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2^20个表项（也就是，在每项3字节时，需要4MB RAM)来表示每个进程的页表（如果进程使用全部4GB线性地址空间），即使一个进程并不适用那个范围内的所有地址，二级模式通过只为进程实际使用的哪些虚拟内存区请求页表来减少内存容量。

每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更有效率。

正在使用的页目录的物理地址存放在控制寄存器`cr3`中。线性地址内的高10位决定页目录项，而页目录项指向适当的页表的物理地址，若页表不在主存中，则会分配相应的1页物理地址，并且将该地址写入到页目录项中。地址的中间10位依次又决定页表中的表项，而表项含有页所在页框的物理地址，若不存在则与上述缺页处理方式一致。偏移字段决定页框内的相对位置。由于它是12位长，故每一页含有4096字节的数据。

页目录项和页表项有同样的结构，每项都包含下面的字段：

- present标志：如果被置为1，所指的页（或页表）就在主存中，如果该标志为0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。
- 包含页框物理地址最高20位的字段：由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0.如果这个字段指向一个页目录，相应的页框就含有一个页表；如果它指向一个页表，相应的页框就含有一页数据。
- Accessed标志：每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志就可以由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。
- Dirty标志：只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，当选中的页被交换出去时，这一标志就可以由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。
- Read/Write标志：含有页或页表的存取权限（读写或读）
- User/Supervisor标志：含有访问页或页表所需的特权级
- PCD和PWT标志：控制硬件高速缓存处理页或页表的方式
- Page Size标志：只应用于页目录项。如果设置为1，则页没目录向指的是2MB或4MB的页框
- Global标志：只应用于页表项。用来防止常用页从TLB高速缓存中刷新出去。只有在cr4寄存器的页全局启用PGE标志置位时这个标志才起作用

## 扩展分页
它允许页框大小为4MB而不是4KB。扩展分页用于把大把连续的线性地址转换成相应的物理地址，在这写情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。

正如前面所述，通过设置页目录项的Page Size标志启用扩展分页功能。在这种情况下，分页单元把32位线性地址分成两个字段：

- 页目录项：最高10位
- offset:其余22位

扩展分页和正常分页的页目录项基本相同，除了

- Page Size标志必须被设置
- 20位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0

通过设置cr4处理器寄存器的PSE标志能使扩展分页和常规分页共存。

## 物理地址扩展（PAE）分页机制
处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。

然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，近几年这对Intel造成了压力，所以必须扩展32位80x86结构所支持的RAM容量。

intel将管脚数从32增加到36已经满足这些需求，寻址能力达到2^36 = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。

通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页（在PAE启用时为2MB）。

Intel为了支持PAE已经改变了分页策略。

- 64GB的RAM被分为2^24个页框，页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。
- 引入一个叫做页目录指针表PDPT的页表新级别，它由4个64位表项组成
- cr3控制寄存器包含一个27位的页目录指针表PDPT基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节（2^5)的倍数上对齐，因此27位足以表示这种表的基地址
- 当把线性地址映射到4KB的页时（也目录项中的PS标志清0），32位线性地址按下列方式解释：

	cr3

		指向一个PDPT

	位31-30

		指向PDPT中4个项中的一个

	位29-21

		指向页目录中512个项中的一个

	位20-12

		指向页表中512项中的一个

	位11-0

		4KB页中的偏移量

- 当把线性地址映射到2MB的页时（页目录项中的PS标志置1），32位线性地址按下列方式解释

	cr3
		
		指向一个PDPT

	
	位31-30

		指向PDPT中4个项中的一个
	
	位29-21

		指向页目录中512个项中的一个

	位20-0

		2MB页中的偏移量

总之，一旦cr3被设置，就可能寻址高达4GB RAM 。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM,从而显著增加了系统中的进程数量。

### 64位系统中的分页
两段分页并不适用于采用64位系统的计算机：

首先假设一个大小为4KB的标准页。因为1KB覆盖2^10个地址的范围，4KB覆盖2^12个地址，所以offset字段是12位。这样线性地址就剩下52位分配给table和directory字段。如果我们现在决定仅仅使用64位中的48位来寻址，剩下的48-12=36位将被分配给table和directory字段。如果我们现在决定为两个字段各预留18位，那么每个进程的页目录和页表都含有2^18个项，即超过256000个项。

由于这个原因，所有64位处理器的硬件分页系统都使用了额外的分页级别。使用的级别数量取决于处理器的类型。

x86_64:页大小4KB；寻址使用的位数 48；分页级别数 4；线性地址分段 9+9+9+9+12，由于一个页表项和页目录项需要64位，所以为了使一个物理页能包含一个页表或者一个页目录表，一页中包含512个页表项和页目录项，所以需要使用9位表示。

