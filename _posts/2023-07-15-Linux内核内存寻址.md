# Linux内核内存寻址
## 内存地址
我们应用内存地址作为访问内存单元内容的一种方式，但是，我们必须区分以下三种不同的地址：

 - 逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的方式。每一个逻辑地址都由一个段选择子（16位）和偏移量（32位）组成，其中段选择子用于从GDT中找到对应的`段描述符`，据此找到段基址，由段基址加上偏移量得到对应的线性地址；
 - 线性地址：线性地址是一个32位无符号整数，可以用来表示高达4GB,范围从0x00000000到0xffffffff
 - 物理地址：用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位无符号整数表示。
 
内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址；接着，第二个称为分页单元的硬件电路把线性地址转换成一个物理地址。

在多处理器系统中，所有CPU都共享同一内存，这意味着RAM芯片可以由独立的CPU并发地访问。因为在RAM芯片上的读或写操作必须串行地执行，因此一种所谓内存仲裁器的硬件电路插在总线和每个RAM芯片之间。其作用是如果某个RAM芯片空闲，就准许一个CPU访问，如果该芯片忙于另一个处理器提出的请求服务，就延迟这个CPU的访问。即使在单处理器上也使用内存仲裁器，因为但处理器系统中包含一个叫做DMA控制器的特殊处理器，而DMA控制器与CPU并发操作。在多处理器系统的情况下，因为仲裁器有多个输入端口，所以其结构更加复杂。

## 硬件中的分段
从80286模型开始，Intel微处理器以两种不同的方式执行地址转换，这两种方式分别称为实模式和保护模式。

### 段选择符和段寄存器
一个逻辑地址由两部分组成，一个段标识符和一个指定段内相对地址的偏移量。段标识符是一个16位长的字段，称为段选择符，而偏移量是一个32位长的字段。

为了快速方便地找到段选择符，处理器提供段寄存器，段寄存器的唯一目的是存放端选择符。这些段寄存器称为cs(代码段寄存器，指向包含程序指令的段）、ds(数据段寄存器）、ss（栈段寄存器、指向包含当前程序栈的段）、fs（堆段寄存器）、es（额外段）。

**段选择符**：16位，`0-1`位为RPL，表示请求特权级，linux中只有00（内核态）和11（用户态）；

`2`位为TI，即表指示器，为0则代表GDT,为1代表LDT

`3-15`位为索引号，根据该索引号到GDT或LDT中找到对应段描述符

cs寄存器还有一个很重要的功能：它含有一个两位的字段，用以指明CPU的当前特权级（CPL)。值0代表最高优先级，值3代表最低优先级。Linux只用0级和3级，分别称之为内核态和用户态。

### 段描述符
每个段描述符由8个字节组成，它放在全局描述符表GDT或者局部描述符表LDT中。

通常只定义一个GDT，而每个进程除了存放在GDT中的段之外如果还需要创建附加的段，就可以有自己的LDT。GDT在主存中的地址和大小存放在dgtr寄存器中，当前正被使用的LDT地址和大小放在ldtr控制寄存器中。

| 字段名 | 描述|
| ----  | ----|
| Base  | 段基地址(线性地址）|
| G     | 粒度标志，如果该位清0，则段大小以字节为单位，该位为1，则以4KB为单位|
| Limit | 段限长，存放段中最后一个内存单元的偏移量，从而决定段的长度|
| S     | 系统标志，如果它被清0，则这是一个系统段，存储LDT这种关键的数据结构，否则它是一个普通的代码段或数据段|
|Type   | 描述段的类型特征和它的存取权限|
| DPL   | 描述符特权级，用于限制对这个段的存取，他表示为访问这个段要求的CPU最小优先级。因此，DPL设为0的段只能当CPL为0时可访问，DPL设为3的段对任何CPL值都是可访问的|
| p     | 段存在标志，为0表示段当前不在主存中，linux总是把这个表示（第47位）设为1，因为它从来不把整个段交换到磁盘上|
| D或B  | 称为D或B的标志，取决于是代码段还是数据段，如果段偏移量地址是32位长，就基本上把它置为1，如果这个偏移量是16位长，它被清0|
| AVL   | 可以被操作系统使用   |

### 快速访问段描述符
我们回忆一下，逻辑地址由16位段选择符和32位偏移量组成，`段寄存器仅仅存放段选择符`。

为了加速逻辑地址到线性地址的转换，处理器提供一种附加的非编程的寄存器（作用类似于虚拟地址到物理地址的TLB高速缓存），供6个段寄存器使用。每一个非编程段寄存器含有8个字节的段描述符，由相应的段寄存器中的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。从那时起，针对那个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接饮用存放段描述符的CPU寄存器即可。仅当段寄存器的内容发生改变时，才有必要访问GDT或LDT。

`段选择符字段`

 - index:指定了放在GDT或LDT中的相应段描述符的入口
 - TI：指明段描述符是在GDT中（TI=0）或在LDT中（TI=1)
 - RPL:请求者特权级：当相应的段选择符装入到cs寄存器中时指示出CPU当前的特权级，它还可以用于在访问数据段时有选择地削弱处理器的特权级

由于一个段描述符是8字节长，因此它在GDT或LDT内的相对地址是由段选择符的最高13位的值乘以8得到的。例如：如果GDT在0x0020000(这个值保存在gdtr寄存器中）。且由段选择符所指定的索引号为2，那么相应的段描述符地址是0x00020000+2x8或0x00020010。

GDT的第一项总是设为0，这就确保空段选择符的逻辑地址会被认为是无效的，因此引起一个处理器异常。能够保存在GDT中的段描述符的最大数目就是2的13次方减去1

### 分段单元
分段单元执行以下操作：

- 先检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中。TI字段指明描述符是在GDT中（在这种情况下，分段单元从gdtr寄存器中得到GDT的线性基地址）还是在激活的LDT中（在这种情况下，分段单元从ldtr寄存器中得到LDT的线性基地址）
- 从段选择符的index字段计算段描述符的地址，index字段的值乘以8（一个段描述符的大小），这个结果与gdtr或ldtr寄存器中的内容相加。
- 把逻辑地址的偏移量与段描述符Base字段的值相加就得到了线性地址。

### Linux中的分段
Linux以非常有限的方式使用分段。实际上，分段和分页在某种程度上有点多余。与分段相比，Linux更喜欢使用分页方式。

四个Linux的段描述符字段的值

|段|Base|G|Limit|S|Type|DPL|D/B|P|
|----|----|----|----|----|----|----|----|----|
|用户代码段|0x00000000|1|0xfffff|1|10|3|1|1|
|用户数据段|0x00000000|1|0xfffff|1|2|3|1|1|
|内核代码段|0x00000000|1|0xfffff|1|10|0|1|1|
|内核数据段|0x00000000|1|0xfffff|1|2|0|1|1|

![](https://img2018.cnblogs.com/i-beta/1827556/202001/1827556-20200108095144191-993268543.png)

相应的段选择符由宏__USER_CS,__USER_DS,__KERNEL_CS,__KERNEL_DS分别定义。例如，为了对内核代码段寻址，内核只需要把__KERNEL_CS宏产生的值装进cs段寄存器即可。

由于所有段基地址都为0，所以linux中逻辑地址偏移量字段的值与相应的线性地址的值总是一致的。

### Linux GDT
每个GDT包含18个段描述符和14个空的，未使用的，或保留的项。插入未使用的项的目的是为了使经常一起访问的描述符能够处于同一个32字节的硬件高速缓存行中。

每一个GDT中包含的18个段描述符指向下列的段：

- 用户态和内核态下的代码段和数据段共4个
- 任务状态段（TSS)，每个处理器有1个。每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都顺序地存放在init_tss数组中，指的说明的是，第n个CPU的TSS描述符的Base字段指向init_tss数组的第n个元素。G标志被清0，而Limit字段置为0xeb,因为TSS段是236字节长。Type字段置为9或11（可用的32位TSS），且DPL置为0，因为不允许用户态下的进程访问TSS段。
- 1个包含缺省局部描述符表的段，这个段通常是被所有进程共享的段
- 3个局部线程存储段TLS：这种机制运行需多线程应用程序使用最多3个局部于线程的数据段。系统调用set_thread_area()和get_thread_area()分别为正在执行的进程创建和撤销一个TLS段
- 与高级电源(AMP)相关的3个段：由于BIOS代码使用段，所以当Linux APM驱动程序调用BIOS函数来获取或者设置APM设备的状态时，就可以使用自定义的代码段和shujuduan
- 与支持即插即用（pnp)功能的BIOS服务程序相关的5个段：与前一种一样，当Linux的pnp设备驱动程序调用BIOS函数来检测pnp设备使用的资源时，使用自定义的代码段和数据段
- 被内核用来处理“双重错误”（处理一个异常时可能会引发另一个异常）的特殊TSS段

每个处理器都有它自己的TSS段，因此其对应的GDT项不同。其次，GDT中只有少数项可能依赖于CPU正在执行的进程（LDT和TLS段描述符）

## 硬件中的分页
分页单元把线性地址转换成物理地址。其中一个关键任务是把所请求的访问类型与线性地址的访问权限相比较，如果这次内存访问是无效的，就产生一个缺页异常。

为了效率起见，线性地址被分成以固定长度为单位的组，称为页。页内部连续的线性地址被映射到连续的物理地址中。这样，内核可以指定一个页的物理地址和其存取权限，而不用指定页所包含的全部线性地址的存取权限。

分页单元把所有的RAM分成固定长度的页框（page frame)(有时叫做物理页）。每一个页框包含一个页，也就是说一个页框的长度和一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中。

把线性地址映射到物理地址的数据结构称为页表。页表存放在主存中，并在启用分页单元之前必须由内核对页表进行适当的初始化。

我们通过设置cr0寄存器的PG标志启用。当PG=0时，线性地址就被解释成物理地址。

## 常规分页
页目录：高10位

页表：中间10位

偏移量：低12位

线性地址的转换分两步未完成，每一步都基于一种转换表，第一种转换表称为页目录表，第二种转换表称为页表。

使用这种二级模式的**目的**在于减少每个进程页表所需RAM的数量。如果使用简单的一级页表，那将需要高达2^20个表项（也就是，在每项3字节时，需要4MB RAM)来表示每个进程的页表（如果进程使用全部4GB线性地址空间），即使一个进程并不适用那个范围内的所有地址，二级模式通过只为进程实际使用的哪些虚拟内存区请求页表来减少内存容量。

每个活动进程必须有一个分配给它的页目录。不过，没有必要马上为进程的所有页表都分配RAM。只有在进程实际需要一个页表时才给该页表分配RAM会更有效率。

正在使用的页目录的物理地址存放在控制寄存器`cr3`中。线性地址内的高10位决定页目录项，而页目录项指向适当的页表的物理地址，若页表不在主存中，则会分配相应的1页物理地址，并且将该地址写入到页目录项中。地址的中间10位依次又决定页表中的表项，而表项含有页所在页框的物理地址，若不存在则与上述缺页处理方式一致。偏移字段决定页框内的相对位置。由于它是12位长，故每一页含有4096字节的数据。

页目录项和页表项有同样的结构，每项都包含下面的字段：

- present标志：如果被置为1，所指的页（或页表）就在主存中，如果该标志为0，则这一页不在主存中，此时这个表项剩余的位可由操作系统用于自己的目的。如果执行一个地址转换所需的页表项或页目录项中present标志被清0，那么分页单元就把该线性地址存放在控制寄存器cr2中，并产生14号异常：缺页异常。
- 包含页框物理地址最高20位的字段：由于每一个页框有4KB的容量，它的物理地址必须是4096的倍数，因此物理地址的最低12位总是为0.如果这个字段指向一个页目录，相应的页框就含有一个页表；如果它指向一个页表，相应的页框就含有一页数据。
- Accessed标志：每当分页单元对相应页框进行寻址时就设置这个标志。当选中的页被交换出去时，这一标志就可以由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。
- Dirty标志：只应用于页表项中。每当对一个页框进行写操作时就设置这个标志。与Accessed标志一样，当选中的页被交换出去时，这一标志就可以由操作系统使用。分页单元从来不重置这个标志，而是必须由操作系统去做。
- Read/Write标志：含有页或页表的存取权限（读写或读）
- User/Supervisor标志：含有访问页或页表所需的特权级
- PCD和PWT标志：控制硬件高速缓存处理页或页表的方式
- Page Size标志：只应用于页目录项。如果设置为1，则页目录项指的是2MB或4MB的页框
- Global标志：只应用于页表项。用来防止常用页从TLB高速缓存中刷新出去。只有在cr4寄存器的页全局启用PGE标志置位时这个标志才起作用

## 扩展分页
它允许页框大小为4MB而不是4KB。扩展分页用于把大把连续的线性地址转换成相应的物理地址，在这写情况下，内核可以不用中间页表进行地址转换，从而节省内存并保留TLB项。

正如前面所述，通过设置页目录项的Page Size标志启用扩展分页功能。在这种情况下，分页单元把32位线性地址分成两个字段：

- 页目录项：最高10位
- offset:其余22位

扩展分页和正常分页的页目录项基本相同，除了

- Page Size标志必须被设置
- 20位物理地址字段只有最高10位是有意义的。这是因为每一个物理地址都是在以4MB为边界的地方开始的，故这个地址的最低22位为0

通过设置cr4处理器寄存器的PSE标志能使扩展分页和常规分页共存。

## 物理地址扩展（PAE）分页机制
处理器所支持的RAM容量受连接到地址总线上的地址管脚数限制。早期Intel处理器使用32位物理地址。从理论上讲，这样的系统上可以安装高达4GB的RAM；而实际上，由于用户进程线性地址空间的需要，内核不能直接对1GB以上的RAM进行寻址。

然而，大型服务器需要大于4GB的RAM来同时运行数以千计的进程，近几年这对Intel造成了压力，所以必须扩展32位80x86结构所支持的RAM容量。

intel将管脚数从32增加到36已经满足这些需求，寻址能力达到2^36 = 64GB。不过，只有引入一种新的分页机制把32位线性地址转换为36位物理地址才能使用所增加的物理地址。

通过设置cr4控制寄存器中的物理地址扩展（PAE）标志激活PAE。页目录项中的页大小标志PS启用大尺寸页（在PAE启用时为2MB）。

Intel为了支持PAE已经改变了分页策略。

- 64GB的RAM被分为2^24个页框，页表项的物理地址字段从20位扩展到了24位。因为PAE页表项必须包含12个标志位和24个物理地址位，总数之和为36，页表项大小从32位变为64位增加了一倍。结果，一个4KB的页表包含512个表项而不是1024个表项。
- 引入一个叫做页目录指针表PDPT的页表新级别，它由4个64位表项组成
- cr3控制寄存器包含一个27位的页目录指针表PDPT基地址字段。因为PDPT存放在RAM的前4GB中，并在32字节（2^5)的倍数上对齐，因此27位足以表示这种表的基地址
- 当把线性地址映射到4KB的页时（也目录项中的PS标志清0），32位线性地址按下列方式解释：

	cr3

		指向一个PDPT

	位31-30

		指向PDPT中4个项中的一个

	位29-21

		指向页目录中512个项中的一个

	位20-12

		指向页表中512项中的一个

	位11-0

		4KB页中的偏移量

- 当把线性地址映射到2MB的页时（页目录项中的PS标志置1），32位线性地址按下列方式解释

	cr3
		
		指向一个PDPT

	
	位31-30

		指向PDPT中4个项中的一个
	
	位29-21

		指向页目录中512个项中的一个

	位20-0

		2MB页中的偏移量

总之，一旦cr3被设置，就可能寻址高达4GB RAM 。如果我们希望对更多的RAM寻址，就必须在cr3中放置一个新值，或改变PDPT的内容。然而，使用PAE的主要问题是线性地址仍然是32位长。这就迫使内核编程人员用同一线性地址映射不同的RAM区。很明显，PAE并没有扩大进程的线性地址空间，因为它只处理物理地址。此外，只有内核能够修改进程的页表，所以在用户态下运行的进程不能使用大于4GB的物理地址空间。另一方面，PAE允许内核使用容量高达64GB的RAM,从而显著增加了系统中的进程数量。

### 64位系统中的分页
两段分页并不适用于采用64位系统的计算机：

首先假设一个大小为4KB的标准页。因为1KB覆盖2^10个地址的范围，4KB覆盖2^12个地址，所以offset字段是12位。这样线性地址就剩下52位分配给table和directory字段。如果我们现在决定仅仅使用64位中的48位来寻址，剩下的48-12=36位将被分配给table和directory字段。如果我们现在决定为两个字段各预留18位，那么每个进程的页目录和页表都含有2^18个项，即超过256000个项。

由于这个原因，所有64位处理器的硬件分页系统都使用了额外的分页级别。使用的级别数量取决于处理器的类型。

x86_64:页大小4KB；寻址使用的位数 48；分页级别数 4；线性地址分段 9+9+9+9+12，由于一个页表项和页目录项需要64位，所以为了使一个物理页能包含一个页表或者一个页目录表，一页中包含512个页表项和页目录项，所以需要使用9位表示。

### 硬件高速缓存
当今的微处理器时钟频率接近几个GHz，而动态RAM(DRAM)芯片的存取时间时时钟周期的数百倍。这意味着，当从RAM中取操作数或向RAM中存放结果这样的指令执行时，CPU可能等待很长时间。

为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存。硬件高速缓存基于著名的局部性原理，该原理既适用于程序结构页适用于数据结构。这表明由于程序的循环结构及相关数组可以组织成线性数组，最近最常用的相邻地址再最近的将来又被用到的可能性极大。因此，引入小而快的内存来存放最近最常使用的代码和数据变得很有意义。为此，引入了高速缓存。

高速缓存单元插在分页单元和主内存之间。它包含一个硬件高速缓存内存和一个高速缓存可能感知器。高速缓存内存存放内存中真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。每个表项有一个标签tag和描述高速缓存行状态的几个标志flag。这个标志由一些位组成，这些位让高速缓存控制器能够辨别由这个行当前所映射的内存单元。这种内存物理地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的子集索引，最低几位对应行内的偏移量。

当访问一个RAM存储单元时，CPU从物理地址中提取子集的索引号并把子集中所有行的标签与物理地址的高几位比较。如果发现某一个行的标签与这个物理地址的高位相同，则CPU命中一个高速缓存，否则，高速缓存没有命中。

当命中一个高速缓存时，高速缓存控制器进行不同的操作，具体取决于存取类型。对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器，不需要访问RAM因而节约了CPU时间，因此，高速缓存系统起到了应有的作用。对于写操作，控制器可能采用以下两个基本策略之一，分别称之为通写和回写。在通写中，控制器总是既写RAM也写高速缓存行，为了提高写操作的效率关闭高速缓存。回写方式只更新高速缓存行，不改变RAM的内容，提供了更快的功效。当然，回写结束以后，RAM最终必须被更新。只有当CPU执行一条要求刷新高速缓存项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存寄存器才把高速缓存行写回到RAM中。因为如果只有一个处理器，采用回写方式，那么读时高速缓存命中会读到最新的内容，并不需要读RAM中旧的数据，只有当我们需要把该高速缓存行换出的时候，我们才需将该高速缓存行写回到RAM。

当高速缓存没有命中时，高速缓存行被写回到内存中，如果有必要的话，把正确的行从RAM中取出放到高速缓存的表项中。

那么如果采用回写方式，多处理器的高速缓存会不会数据不一致呢？

答案：多处理器系统的每一个处理器都有一个单独的硬件高速缓存，因此它们需要额外的硬件电路用于保持高速缓存内容的同步。每个CPU都有自己的本地硬件高速缓存。但是，现在更新变得更耗时，只要一个CPU修改了它的硬件高速缓存，它就必须检查同样的数据是否包含在其他的硬件高速缓存中，如果是，它必须通知其他CPU用适当的值对其更新。常把这种活动叫做高速缓存侦听。值得庆幸的是，所有这一切都在硬件级处理，内核无需关心。

Linux忽略硬件细节并假定只有一个单独的高速缓存，因为多级高速缓存之间的一致性是由硬件实现的。

处理器的cr0寄存器的`CD`标志位用来启用或禁用高速缓存电路。这个寄存器中的`NW`标志指明高速缓存是使用通写还是回写策略。

每一个页目录项和每一个页表项都包含两个标志：PCD（page Cache Disable)标志指明当访问包含在这个页框中的数据时，高速缓存功能必须被启用还是禁用。PWT（page Write-Through)标志指明当把数据写到页框时，必须使用的策略是回写策略还是通写策略。Linux清楚了所有页目录项和页表项中的PCD和PWT标志：结果是：对于所有的页框都启用高速缓存，对于写操作总是采用回写策略。

### 转换后援缓冲器TLB
除了通用硬件高速缓存之外，还有一个叫做TLB的高速缓存用于加快线性地址的转换。当一个线性地址被第一次使用时，通过慢速访问RAM中的页表计算出相应的物理地址。同时，物理地址被存放在一个TLB表项中，以便以后对同一个线性地址的引用可以快速地得到转换。

在多处理器系统中，每个CPU都有自己的TLB，这叫做该CPU的本地TLB。与硬件高速缓存相反，TLB中的对应项不必同步，这是因为运行在现有CPU上的进程可以使同一线性地址与不同的物理地址发生联系。

当CPU的cr3控制寄存器被修改时，硬件自动使本地TLB中的所有项都无效，这是因为新的一组页表被启用而TLB指向的是旧数据。

### Linux中的分页
Linux采用了一种同时适用于32位和64位系统的普通分页模型。两级页表对32位系统来说已经足够了，但64位操作系统需要更多数量的分页级别。

4种页表分别称为：

- 页全局目录
- 页上级目录
- 页中间目录
- 页表

页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址。每一个页表项指向一个页框。线性地址因此被分为五个部分。并且每一部分的大小与具体的计算机体系结构有关。

对于没有启用物理地址扩展的32位系统，两级页表已经足够了。Linux通过使页上级目录位和页中间目录位全为0，从根本上取消了页上级目录和页中间目录字段。不过，页上级目录和页中间目录在指针序列中的位置被保留，以便同样的代码在32位和64位系统下都能使用。内核为页上级目录和页中间目录保留了一个位置，这是通过把它们的页目录项数设置为1，并把这两个目录项映射到页全局目录的一个适当的目录项而实现的。

启用了物理地址扩展的32位系统使用了三级页表。Linux的页全局目录对应80x86的页目录指针表PDPT，取消了页上级目录，页中间目录对应80x86的页目录，Linux的页表对应80x86的页表。

最后，64位系统使用三级还是四级分页取决于硬件对线性地址的位的划分。

Linux的进程处理很大程度上依赖于分页，事实上，线性地址到物理地址的自动转换使下面的设计目标变得可行：

- 给每一个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误
- 区别页（即一组数据）和页框（即主存中的物理地址）之不同。这就允许存放在某个页框中的一个页，然后保存在磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。

每个进程都有它自己的页全局目录和自己的页表集。当发生进程切换时，Linux把cr3控制寄存器的内容保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。因此，当新进程重新开始在CPU上执行时，分页单元指向一组正确的页表。

### 线性地址字段
下列宏简化了页表处理：

- PAGE_SHIFT:指定Offset字段的位数，当用于80x86处理器时，它产生的值为12。由于页内所有地址都必须能放到Offset字段中，因此80x86系统的页的大小是2^12=4096字节。PAGE_SHIFT的值为12可以看作以2为底的页大小的对数。这个宏由PAGE_SIZE使用以返回页的大小。最后，PAG_MASK宏产生的值为0xfffff000，用以屏蔽Offset字段的所有位。
- PMD_SHIFT：指定线性地址的Offset字段和Table字段的总位数，换句话说，是页中间目录项可以映射的区域大小的对数。PMD_SIZE宏用于计算由页中间目录的一个单独表项所映射的区域大小，也就是一个页表的大小。PMD_MASK宏用于屏蔽Offset字段与Table字段的所有位。当PAE被禁用时，PMD_SHIFT产生的值为22（10+12），PMD_SIZE产生的值为4MB，PMD_MASK产生的值为0xffc00000.相反，当PAE被激活时，PMD_SHIFT产生的值为21（9+12），PMD_SIZE产生的值为2MB,PMD_MASK产生的值为0xffe00000。大型页不使用最后一级页表，所以产生大型页尺寸的LARGE_PAGE_SIZE宏等于PMD_SIZE(2PMD_SHIFT),而在大型页地址中用于屏蔽Offset字段和Table字段的所有位的LARGE_PAGE_MASK宏，就等于PMD_MASK。
- PUD_SHIFT：确定页上级目录项能映射的区域大小的对数
- PGDIR_SHIFT：确定页全局目录项能映射的区域大小的对数

## 页表处理
pte_t、pmd_t、pud_t和pgd_t分别描述页表项、页中间目录项、页上级目录和页全局目录项的格式。当PAE被激活时它们都是64位的数据类型，否则都是32位数据类型。
内核还提供了许多宏和函数用于读或者修改页表表项：
- 如果相应的表项值为0，那么，宏pte_none、pmd_none、pud_none和pgd_none产生的值为，否则产生的值为0
- 宏pte_clear、pmd_clear、pud_clear和pgd_clear清除相应页表的一个表项，由此进制进程使用由该页表映射的线性地址。ptep_get_and_clear()函数清除一个页表项并返回前一个值
- set_pte、set_pmd、set_pud和set_pgd向一个页表项中写入指定的值。set_pte_atomic与set_pte作用相同，但是原子写入
- 如果a和b两个页表项指向同一页并且指定相同的访问优先级，那么pte_same(a,b)返回1，否则返回0
- 如果页中间目录项e指向一个大型页（2MB或4MB），那么pmd_large(e)返回1，否则返回0
宏pmd_bad由函数使用并通过输入参数传递来检查页中间目录项。如果目录项指向一个不能使用的页表，也就是说，如果出现以下条件中的一个，则这个宏产生的值为1
- 页不在主存中（Present标志被清除）
- 页只允许读访问（Read/Write标志被清除）
- Acessed或者Dirty位被清除（对于每个现有的页表，Linux总是强制设置这些标志）

pud_bad宏和pgd_bad宏总是产生0.没有定义pte_bad宏，因为页表项应用一个不在主存中的页、一个不可写的页或一个根本无法访问的页都是合法的

如果一个页表项的Present标志或者Page Size标志等于1，则pte_present宏产生的值为1，否则为0。前面讲过页表项的Page Size标志对于当前在主存中却又没有读、写或执行权限的页，内核将其Present和Page Size分别标记为0和1.这样，任何试图对此类页的访问都会引起一个缺页异常，因为页的Present标志被清0，而内核可以通过检查Page Size的值来检测到产生异常并不是因为缺页

如果相应表项的Present标志等于1，也就是说，若果对应的页或者页表被载入主存，pmd_present宏产生的值为1.pud_present宏和pgd_present宏产生的值总是1

以下所有函数，除了pte_file()外，其他函数都只有在pte_present返回1的时候，才能正常返回页表项中任意一个标志

pte_user() 读User/Supervisor标志

pte_read() 读User/Supervisor标志（80x86处理器上的页不受读的保护）

pte_write() 读Read/Write标志

pte_exec() 读User/Supervisor标志（80x86处理器上的页不受代码执行的保护）

pte_dirty() 读Dirty标志

pte_young() 读Accessed标志

pte_file() 读Dirty标志（当Present标志被清除而Dirty标志被设置时，页属于一个非线性磁盘文件映射）



