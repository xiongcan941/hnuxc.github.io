# 硬件结构
## CPU缓存一致性
随着时间的推移，CPU和内存的访问性能相差越来越大，于是就在CPU内部嵌入了CPU Cache(高速缓存），CPU Cache离CPU核心相当近，因此它的访问速度是很快的，于是它充当了CPU与内存之间的缓存角色。

CPU Cache通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离CPU核心越近，访问速度越快，但是存储容量相对就会越小。其中，在多核心的CPU里，每个核心都有各自的L1/L2 Cache，而L3 Cache是所有核心共享使用的。

高速缓存存储空间设计：存储分组，组中分行，行中分字节。

高速缓存被划分成S个组，每个组由E行数据，每行中有一个高速缓存块，每个高速缓存块的大小是B个字节。

基本思路：先找到组，然后找到行，最后再通过便宜找到块中的具体字节。

组相连映射：所谓组相连映射：主存中的每一块可以被放置到Cache中唯一的一个组中的任何一个位置。

事实上，数据不光是只有读操作，还有写操作，那么如果数据写入Cache之后，内存与Cache相对应的数据将会不同，这种情况下Cache和内存数据都不一致了，于是我们肯定是要把Cache中的数据同步到内存里的。

一下是两种方式把Cache中的数据写回到内存：
- 直写：把数据同时写入内存和Cache中
- 写回：当发生写操作时，新的数据仅仅被写入Cache Block里，只有当修改过的Cache Block[被替换]时才需要写到内存中，减少了数据写回内存的频率，这样便可以提高系统的性能。

## 缓存一致性问题
现在CPU都是多核的，由于L1/L2 Cache时多个核心各自独有的，那么会带来多核心的缓存一致性的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。

例如两个核心都对各自高速缓存中的数据进行写操作。

那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这2点：
- 第一点，某个CPU核心里的Cache数据更新时，必须要传播到其他核心的Cache，这个称为写传播
- 第二点，某个CPU核心里对数据的操作顺序，必须再其他核心看起来顺序是一样的，这个称为事务的串行化。

要实现事务串行化，要做到2点：
- CPU核心对于Cache中数据的操作，需要同步给其他CPU核心
- 要引入`锁`的概念，如果两个CPU核心里有相同数据的Cache，那么对于这个Cache数据的更新，只有拿到了`锁`，才能进行对应的数据更新。

## MESI协议
MESI协议其实是4个状态单词的开头字母缩写，分别是：
- Modified，已修改
- Exclusive，独占
- Shared，共享
- Invalidated，已失效

这四个状态来标记Cache Line四个不同的状态。

[已修改]状态就是我们前面提到的脏标记，代表该Cache Block上的数据已经被更新过，但是还没有写到内存里。而[已失效]状态，表示的是这个Cache Block里的数据已经失效了，不可以读取该状态的数据。

[独占]和[共享]状态都代表Cache Block里的数据是干净的，也就是说，这个时候Cache Block里的数据和内存里面的数据是一致性的。

[独占]和[共享]的差别在于，独占状态的时候，数据只存储再一个CPU核心的Cache里，而其他CPU核心的Cache没有该数据。这个时候，如果要向独占的Cache写数据，就可以直接自由地写入，而不需要通知其他CPU核心，因为只有你这有这个数据，就不存在缓存一致性的问题，于是就可以随便操作该数据。

另外，再[独占]状态下的数据，如果有其他核心从内存读取了相同的数据到各自的Cache，那么这个时候，独占状态下的数据就会变成共享状态。

那么，[共享]状态代表着相同的数据在多个CPU核心的Cache里都有，所以当我们要更新Cache里面的数据的时候，不能直接修改，而是要先向所有的其他CPU核心广播一个请求，要求先把其他核心的Cache中对应的Cache Line标记为[无效]状态，然后再更新当前Cache里面的数据。



