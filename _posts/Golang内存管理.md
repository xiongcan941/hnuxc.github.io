# Golang内存管理

## 栈内存管理

栈区用于存储局部变量，其内存的分配和释放基本都是在编译时确定的。

Go语言汇编代码包含BP和SP两个栈寄存器，它们分别存储了栈的基地址和栈顶的地址。

## 分段栈（v1.3之前）

多个栈空间会以链表的形式串联起来，运行时会通过指针找到连续的栈片段。

我觉得这个产生的原因可能是编译时为Goroutinue分配的栈空间少了，所以会扩容。

栈空间会按需扩张收缩。当空间不足时，会创建一个新的栈空间，加入链表。相应的，当空间不再用到时，会缩容。

1.使用内存空间超过扩缩容阈值时，会触发栈的扩容和缩容，带来额外消耗

2.存在热分裂问题

    例如：当前Goroutinue的栈空间几乎充满，则在进行任意的函数调用都会触发栈扩容，当函数返回后又会触发栈的缩容。当在一个循环中调用函数时，会发生频繁的扩缩容，造成巨大的额外开销。

## 连续栈（v1.3之后）

栈空间不足时，初始化一片更大的栈空间，并将原栈中的所有值都复制到新栈中。

1.栈扩容时，增加了拷贝变量和调整指针的额外开销

2.通过一定的栈缩容机制避免频繁扩缩容，造成热分裂。（扩容时，新栈空间是原来两倍；缩容时，新栈空间是原来1/2

## 堆内存管理

内存管理一般包含三个不同的组件，分别是用户程序、分配器和收集器，当用户程序申请内存时，它会通过内存分配器申请新内存，而分配器会负责从堆中初始化相应的内存区域。

## 堆内存分配

### 分级分配

1.分配内存大小分级

    内存分配器会根据申请分配的内存大小选择不同的处理逻辑，根据内存大小主要分为3类：

- 微对象：大小（0，16B）非指针类型

- 小对象：[16B,32KB]

- 大对象：(32KB,+无穷)

2.分配过程分级

    对于不同内存大小分级，在分配的处理逻辑各不相同。

    逻辑上，引入Thread Cache、Central Cache和Page Heap三个组件分级管理内存

- Thread Cache对应于每一个独立的线程，用于线程上绝大多数的内存分配

- 当Thread Cache无可用内存时，会从Central Cache申请内存，作为补充来解内存分配

- 当Central Cache无可用内存时，会从Page Heap申请内存

- 当Page Heap无可用内存时，会向系统申请内存

具体到实现的话，golang程序在启动时初始化的分级分配的内存布局如下：

- mcache:对应Thread Cache，用于处理线程微对象和小对象的分配。其中，mcache会持有mspan用于小对象内存分配；类似于slab分配算法，每个slab对应一个或多个page，然后在page中分配小对象object

- mheap:用于管理整个堆区的内存分配。
  
  - mcentral:不同mcentral对应不同spanClass，会持有mspan。在mcache无可用内存时，会向mcentral申请mspan，用于内存分配。
  
  - heapArena:用于管理整个程序堆区的内存块。在mheap中是一个heapArena数组，不同heapArena指向不同内存块，使得堆区的内存在虚拟内存中可以是不连续的。

### mcache

- tiny、tinyoffset、tinyAllocs
  
  用于非指针类型的微对象（大小（0，16B))的分配

- tiny指向堆中的一片内存，指向当前用于分配微小对象的内存开头；如果没有，则为nil

- mspan为mcache从mcentral中申请的一块内存空间，用于分配微小对象

- tinyoffset为下一个空闲内存所在的偏移量

- tinyAllocs为分配的微对象个数

- alloc：即为用于分配内存的mspan数组。数组大小为span类型总数的2倍（68*2），即每种span类型都有两个mspan，一个表示的对象中包含了指针（scan)，另一个中表示的对象不含有指针（noscan)。（为了提高GC扫描性能，对于noscan没必要去扫描，而scan则需要GC进行扫描。mcache在刚被初始化时alloc中mspan时空的占位符。当mcache中mspan的空闲内存不足时，会向mcentral组件请求获取mspan

- stackcache：线程栈缓存

### mspan

mspan时一个内存管理的一个基本单元。每个mspan都对应一个大小等级，小对象类型的堆对象会根据其大小分配到相应设定好大小等级mspan上分配内存，和slab一样由链表连接起来

https://bytedance.larkoffice.com/wiki/YqaTwA8M8igFbdke76BcMYqFn9g
