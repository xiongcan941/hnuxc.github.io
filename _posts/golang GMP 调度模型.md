![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.001.png)

# golang GMP 调度模型

|<p>参考文档：https://www.yuque.com/aceld/golang/srxd6d</p><p>[Golang 调度模型与 GMP](https://bytedance.feishu.cn/wiki/wikcnmGbcQKn3q5aLq2jZ1tuDIf) [协程和Golang GMP调度模型](https://bytedance.feishu.cn/docs/doccnayMmy0GHZWPfJL4XrHToKb#) </p>|
| :- |

<a name="heading_0"></a>**一、Golang“调度器”的由来？**

<a name="heading_1"></a>**(1) 单进程时代不需要调度器**

我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”：一切的程序只能串行发生。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.002.png)

早期的单进程操作系统，面临2个问题：

1\.单一的执行流程，计算机只能一个任务一个任务处理。

2\.进程阻塞所带来的CPU时间浪费。

那么能不能有多个进程来宏观一起来执行多个任务呢？

后来操作系统就具有了**最早的并发能力：多进程并发**，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。

<a name="heading_2"></a>**(2)多进程/线程时代有了调度器需求**

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.003.png)

在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。

但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。

**怎么才能提高CPU的利用率呢？**

但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.004.png)

很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。

<a name="heading_3"></a>**进程切换的代价分析**

- 通过系统调用进入/退出内核态
- 用户态到内核态的切换其实与狭义的进程切换很相似，包含用户栈到内核栈，用户代码段到内核代码段等。
- 调度算法的维护和计算代价
- 各个task的权重维护和排序代价
- 内存空间切换的代价
- tlb和cache的切换，会破坏程序的局部性，降低程序的运行速度
- 进程上下文切换
- 栈切换，硬件上下文切换，代码段切换

|Linux 2.6之后，linux POSIX线程实现是NPTL（Native POSIX Thread Library），也就是我们现在使用的线程实现。NPTL的线程模型实现使用了1：1的线程模型。这种方式下，线程与进程的差别不大，同一个进程的多个线程使用相同的虚拟内存，主要区别在于不同的线程会存在**各自的栈和控制块**，并**独自被内核调度**。|
| :- |

<a name="heading_4"></a>**线程切换的代价分析**

- 通过系统调用进入/退出内核态
- 调度算法的维护和计算代价
- 线程上下文切换

  <a name="heading_5"></a>**(3) 协程来提高CPU利用率**

协程（coroutine）又叫做用户空间线程，强调「用户空间的」原因在于，协程的实现方式是在用户空间里模拟上下文切换和调度，来避免进入内核态。它区别于进程和线程的主要特点是，协程的调度，切换和具体实现都是用户可定义的，不需要进入内核态，最大化的降低内核级别的调度和上下文切换。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.005.png)

既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。

<a name="heading_6"></a>**M:N关系**

M个协程绑定N个线程。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.006.png)

协程跟线程是有区别的，线程由CPU调度是抢占式的，**协程由用户态调度是协作式的**，一个协程让出CPU后，才执行下一个协程。

<a name="heading_7"></a>**(4) Go语言的协程goroutine**

**Go为了提供更容易使用的并发方法，使用了goroutine和channel**。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。

Goroutine特点：

- 占用内存更小（几kb）
- 调度更灵活(runtime调度)

<a name="heading_8"></a>**(5) 被废弃的goroutine调度器**

Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.007.png)

G表示Goroutine，M来表示线程。M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。

老调度器有几个缺点：

1. 创建、销毁、调度G都需要每个M获取锁，这就形成了**激烈的锁竞争**。
2. M转移G会造成**延迟和额外的系统负载**。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了**很差的局部性**，因为G’和G是相关的，最好放在M上执行，而不是其他M'。
3. 系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。

<a name="heading_9"></a>**二、Goroutine调度器的GMP模型的设计思想**

<a name="heading_10"></a>**(1) GMP模型**

G：goroutine

- 当go一个func时，就是启动了创建了一个goroutine

  M：machine

- 对应内核线程，一个M代表一个内核级线程
- 可以通过debug.SetMaxThreads来设置最大的M数量

  P：processor

- 逻辑上的处理器，做为桥梁链接G和M
- 在程序初始化时，通过GOMAXPROCS环境变量来指定分配的内核线程数量

  面对之前调度器的问题，Go设计了新的调度器。

在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。

**Processor，它包含了运行goroutine的资源**，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。

在Go中，**线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上**。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.008.png)

1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

**Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。

<a name="heading_11"></a>**有关P和M的个数问题**

1、P的数量：

- 由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。

  2、M的数量:

- go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。
- runtime/debug中的SetMaxThreads函数，设置M的最大数量
- 一个M阻塞了，会创建新的M。

  M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

<a name="heading_12"></a>**P和M何时会被创建**

1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。

<a name="heading_13"></a>**(2) 调度器的设计策略**

**复用线程**：避免频繁的创建、销毁线程，而是对线程的复用。

1）work stealing机制

当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.009.png)

2）hand off机制

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.010.png)

当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

**利用并行**：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。

**抢占**：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。

**全局G队列**：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。

<a name="heading_14"></a>**(3) go func()  调度流程**

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.011.png)

从上图我们可以分析出几个结论：

`        `1、通过 go func()来创建一个goroutine；

`        `2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

`        `3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

`        `4、一个M调度G执行的过程是一个循环机制；

`        `5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

`        `6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。

<a name="heading_15"></a>**(4) 调度器的生命周期**

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.012.png)

特殊的M0和G0：

**M0**

M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。

**G0**

G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。

我们来跟踪一段代码

|Go<br>package main<br><br>import "fmt"<br><br>func main() {<br>`    `fmt.Println("Hello world")<br>}|
| :- |

接下来针对上面的代码对调度器里面的结构做一个分析。

也会经历如上图所示的过程：

1. runtime创建最初的线程m0和goroutine g0，并把2者关联。
2. 调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。
3. 示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。
4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。

调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。

<a name="heading_16"></a>**三、Go调度器调度场景过程全解析**

<a name="heading_17"></a>**场景1**

P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P1的本地队列。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.013.png)

<a name="heading_18"></a>**场景2**

G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.014.png)

<a name="heading_19"></a>**场景3**

假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.015.png)

<a name="heading_20"></a>**场景4**

G2在创建G7的时候，发现P1的本地队列已满，需要执行**负载均衡**(把P1中本地队列中前一半的G，还有新创建G**转移**到全局队列)，实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.016.png)

这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。

<a name="heading_21"></a>**场景5**

G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.017.png)

G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。

<a name="heading_22"></a>**场景6**

规定：**在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行**。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.018.png)

假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程**（没有G但为运行状态的线程，不断寻找G）**。

<a name="heading_23"></a>**场景7**

M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()），至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是**从全局队列到P本地队列的负载均衡**。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.019.png)

假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。

<a name="heading_24"></a>**场景8**

假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.020.png)


**全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列**。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。

<a name="heading_25"></a>**场景9**

G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于**自旋状态**，它们不断寻找goroutine。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.021.png)

为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们**希望当有新goroutine创建时，立刻能有M运行它**，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS=4，所以一共4个P)，多余的没事做线程会让他们休眠。

<a name="heading_26"></a>**场景10**

假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M>=P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了**阻塞的系统调用**，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.022.png)

<a name="heading_27"></a>**场景11**

G8创建了G9，假如G8进行了**非阻塞系统调用**。

![](Aspose.Words.563a0ceb-beb7-4371-a24a-a4e38a8f2bc5.023.png)

M2和P2会解绑，但M2会记住P2，然后G8和M2进入**系统调用**状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。


